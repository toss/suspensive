---
sidebar_position: 2
title: <ErrorBoundary/>
---

this component can handle any errors in children

### props.fallback

If there is any thrown error in children of `<ErrorBoundary/>`, Error will be caught and then fallback will be rendered.

```tsx
import { ErrorBoundary } from '@suspensive/react'
import { useState, useEffect } from 'react'

const Example = () => (
  <ErrorBoundary
    fallback={(props) => (
      <>
        <button onClick={props.reset}>Try again</button>
        {props.error.message}
      </>
    )}
  >
    <ErrorAfter4s />
  </ErrorBoundary>
)

const ErrorAfter4s = () => {
  const [asyncState, setAsyncState] = useState<{ isError: true; error: Error } | { isError: false; error: null }>({
    isError: false,
    error: null,
  })

  useEffect(() => {
    setTimeout(() => {
      setAsyncState({ isError: true, error: { status: 401, message: 'unauthorized' } })
    }, 4000)
  }, [])

  if (asyncState.isError) {
    throw asyncState.error
  }

  return <>No error</>
}
```

![Example banner](/gif/errorboundary-example.gif)

### props.resetKeys

If you want to reset `<ErrorBoundary/>` by component where is outside of `<ErrorBoundary/>`'s fallback. Inject any resetKey in resetKeys. resetKeys work only when at least one element of array is changed. you don't need to worry about provide new array as resetKeys like how useEffect's dependency array work.

```tsx
import { ErrorBoundary } from '@suspensive/react'
import { useState } from 'react'

const Example = () => {
  const [resetKey, setResetKey] = useState(0)

  return (
    <>
      <button onClick={() => setResetKey((prev) => prev + 1)}>Try again</button>
      <ErrorBoundary resetKeys={[resetKey]}>
        <ErrorAfter4s />
      </ErrorBoundary>
    </>
  )
}
```

### props.onReset

This is a callback that is called first when `<ErrorBoundary/>` reset. It can be used with @tanstack/react-query as follows.

```tsx
import { ErrorBoundary } from '@suspensive/react'
import { QueryErrorResetBoundary } from '@tanstack/react-query'

const Example = () => (
  <QueryErrorResetBoundary>
    {({ reset }) => (
      <ErrorBoundary
        onReset={reset}
        fallback={(props) => (
          <>
            <button onClick={props.reset}>Try again</button>
            {props.error.message}
          </>
        )}
      >
        <Page />
      </ErrorBoundary>
    )}
  </QueryErrorResetBoundary>
)
```

### props.onError

This is a callback called when `<ErrorBoundary/>` catches an error.

```tsx
import { ErrorBoundary } from '@suspensive/react'

const logError = (error: Error, info: ErrorInfo) => {
  // ...
}

const Example = (
  <ErrorBoundary fallback={ErrorBoundaryFallback} onError={logError}>
    <Error />
  </ErrorBoundary>
)
```

## useErrorBoundary

:::caution Experimental

useErrorBoundary is experimental feature, this interfaces could be changed

:::

We can reset `<ErrorBoundary/>` without props using useErrorBoundary.reset in ErrorBoundaryFallback.

```tsx
import { ErrorBoundary, useErrorBoundary } from '@suspensive/react'

const ErrorBoundaryFallback = () => {
  const errorBoundary = useErrorBoundary()

  return <button onClick={errorBoundary.reset}>Try again</button>
}

const Example = () => (
  <ErrorBoundary fallback={ErrorBoundaryFallback}>
    <Error />
  </ErrorBoundary>
)
```

In children of `<ErrorBoundary/>`, we can use useErrorBoundary.setError to make `<ErrorBoundary/>` aware of the Error without throw.

```tsx
import { ErrorBoundary, useErrorBoundary } from '@suspensive/react'
import { useEffect } from 'react'

const Example = () => (
  <ErrorBoundary fallback={ErrorBoundaryFallback}>
    <SetErrorAfterFetch />
  </ErrorBoundary>
)

const SetErrorAfterFetch = () => {
  const errorBoundary = useErrorBoundary()

  useEffect(() => {
    fetchSomething().then(
      (response) => {},
      (error) => errorBoundary.setError(error) // instead of throw inside
    )
  }, [])

  return <>...</>
}
```

## withErrorBoundary

We can use withErrorBoundary to wrap component by `<ErrorBoundary/>` easily.
we don't need to make unncessary code to wrap it if we use withErrorBoundary like below.
withErrorBoundary's 2nd parameter is props of `<ErrorBoundary/>` without children

```tsx
import { withErrorBoundary, useErrorBoundary } from '@suspensive/react'

const Example = withErrorBoundary(
  function Component() {
    const errorBoundary = useErrorBoundary()

    return <>...</>
  },
  { fallback: ErrorBoundaryFallback }
)
```

:::tip

### Controlling multiple `<ErrorBoundary/>`s

`<ErrorBoundary/>` is more powerful when used with `<ErrorBoundaryGroup/>`. Control multiple `<ErrorBoundary/>`s with `<ErrorBoundaryGroup/>`. Details are introduced in [`<ErrorBoundaryGroup/>` page](./ErrorBoundaryGroup.i18n).

:::
